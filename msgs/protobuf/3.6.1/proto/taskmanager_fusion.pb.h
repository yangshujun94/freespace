// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: taskmanager_fusion.proto

#ifndef PROTOBUF_INCLUDED_taskmanager_5ffusion_2eproto
#define PROTOBUF_INCLUDED_taskmanager_5ffusion_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_taskmanager_5ffusion_2eproto 

namespace protobuf_taskmanager_5ffusion_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_taskmanager_5ffusion_2eproto
namespace atd {
namespace taskmanager {
namespace fusion {
class BayInfo;
class BayInfoDefaultTypeInternal;
extern BayInfoDefaultTypeInternal _BayInfo_default_instance_;
class BlockBoxInfo;
class BlockBoxInfoDefaultTypeInternal;
extern BlockBoxInfoDefaultTypeInternal _BlockBoxInfo_default_instance_;
class BlockObstacleInfo;
class BlockObstacleInfoDefaultTypeInternal;
extern BlockObstacleInfoDefaultTypeInternal _BlockObstacleInfo_default_instance_;
class BlockRtgInfo;
class BlockRtgInfoDefaultTypeInternal;
extern BlockRtgInfoDefaultTypeInternal _BlockRtgInfo_default_instance_;
class BrigeInfo;
class BrigeInfoDefaultTypeInternal;
extern BrigeInfoDefaultTypeInternal _BrigeInfo_default_instance_;
class BrigeQcInfo;
class BrigeQcInfoDefaultTypeInternal;
extern BrigeQcInfoDefaultTypeInternal _BrigeQcInfo_default_instance_;
class MultipleVehiclesRoutes;
class MultipleVehiclesRoutesDefaultTypeInternal;
extern MultipleVehiclesRoutesDefaultTypeInternal _MultipleVehiclesRoutes_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class RouteInfo;
class RouteInfoDefaultTypeInternal;
extern RouteInfoDefaultTypeInternal _RouteInfo_default_instance_;
class TaskManager2Fusion;
class TaskManager2FusionDefaultTypeInternal;
extern TaskManager2FusionDefaultTypeInternal _TaskManager2Fusion_default_instance_;
}  // namespace fusion
}  // namespace taskmanager
}  // namespace atd
namespace google {
namespace protobuf {
template<> ::atd::taskmanager::fusion::BayInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BayInfo>(Arena*);
template<> ::atd::taskmanager::fusion::BlockBoxInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BlockBoxInfo>(Arena*);
template<> ::atd::taskmanager::fusion::BlockObstacleInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BlockObstacleInfo>(Arena*);
template<> ::atd::taskmanager::fusion::BlockRtgInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BlockRtgInfo>(Arena*);
template<> ::atd::taskmanager::fusion::BrigeInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BrigeInfo>(Arena*);
template<> ::atd::taskmanager::fusion::BrigeQcInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::BrigeQcInfo>(Arena*);
template<> ::atd::taskmanager::fusion::MultipleVehiclesRoutes* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::MultipleVehiclesRoutes>(Arena*);
template<> ::atd::taskmanager::fusion::Point* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::Point>(Arena*);
template<> ::atd::taskmanager::fusion::RouteInfo* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::RouteInfo>(Arena*);
template<> ::atd::taskmanager::fusion::TaskManager2Fusion* Arena::CreateMaybeMessage<::atd::taskmanager::fusion::TaskManager2Fusion>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace atd {
namespace taskmanager {
namespace fusion {

// ===================================================================

class Point : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // optional double latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.Point)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double longitude_;
  double latitude_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockRtgInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BlockRtgInfo) */ {
 public:
  BlockRtgInfo();
  virtual ~BlockRtgInfo();

  BlockRtgInfo(const BlockRtgInfo& from);

  inline BlockRtgInfo& operator=(const BlockRtgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockRtgInfo(BlockRtgInfo&& from) noexcept
    : BlockRtgInfo() {
    *this = ::std::move(from);
  }

  inline BlockRtgInfo& operator=(BlockRtgInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BlockRtgInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockRtgInfo* internal_default_instance() {
    return reinterpret_cast<const BlockRtgInfo*>(
               &_BlockRtgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BlockRtgInfo* other);
  friend void swap(BlockRtgInfo& a, BlockRtgInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockRtgInfo* New() const final {
    return CreateMaybeMessage<BlockRtgInfo>(NULL);
  }

  BlockRtgInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockRtgInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BlockRtgInfo& from);
  void MergeFrom(const BlockRtgInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockRtgInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.Point rtgScopeCoordinate = 3;
  int rtgscopecoordinate_size() const;
  void clear_rtgscopecoordinate();
  static const int kRtgScopeCoordinateFieldNumber = 3;
  ::atd::taskmanager::fusion::Point* mutable_rtgscopecoordinate(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
      mutable_rtgscopecoordinate();
  const ::atd::taskmanager::fusion::Point& rtgscopecoordinate(int index) const;
  ::atd::taskmanager::fusion::Point* add_rtgscopecoordinate();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
      rtgscopecoordinate() const;

  // optional string rtgNo = 1;
  bool has_rtgno() const;
  void clear_rtgno();
  static const int kRtgNoFieldNumber = 1;
  const ::std::string& rtgno() const;
  void set_rtgno(const ::std::string& value);
  #if LANG_CXX11
  void set_rtgno(::std::string&& value);
  #endif
  void set_rtgno(const char* value);
  void set_rtgno(const char* value, size_t size);
  ::std::string* mutable_rtgno();
  ::std::string* release_rtgno();
  void set_allocated_rtgno(::std::string* rtgno);

  // optional .atd.taskmanager.fusion.Point rtgCenterPos = 2;
  bool has_rtgcenterpos() const;
  void clear_rtgcenterpos();
  static const int kRtgCenterPosFieldNumber = 2;
  private:
  const ::atd::taskmanager::fusion::Point& _internal_rtgcenterpos() const;
  public:
  const ::atd::taskmanager::fusion::Point& rtgcenterpos() const;
  ::atd::taskmanager::fusion::Point* release_rtgcenterpos();
  ::atd::taskmanager::fusion::Point* mutable_rtgcenterpos();
  void set_allocated_rtgcenterpos(::atd::taskmanager::fusion::Point* rtgcenterpos);

  // optional int64 nTimeStamp = 4;
  bool has_ntimestamp() const;
  void clear_ntimestamp();
  static const int kNTimeStampFieldNumber = 4;
  ::google::protobuf::int64 ntimestamp() const;
  void set_ntimestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BlockRtgInfo)
 private:
  void set_has_rtgno();
  void clear_has_rtgno();
  void set_has_rtgcenterpos();
  void clear_has_rtgcenterpos();
  void set_has_ntimestamp();
  void clear_has_ntimestamp();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point > rtgscopecoordinate_;
  ::google::protobuf::internal::ArenaStringPtr rtgno_;
  ::atd::taskmanager::fusion::Point* rtgcenterpos_;
  ::google::protobuf::int64 ntimestamp_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BayInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BayInfo) */ {
 public:
  BayInfo();
  virtual ~BayInfo();

  BayInfo(const BayInfo& from);

  inline BayInfo& operator=(const BayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BayInfo(BayInfo&& from) noexcept
    : BayInfo() {
    *this = ::std::move(from);
  }

  inline BayInfo& operator=(BayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BayInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BayInfo* internal_default_instance() {
    return reinterpret_cast<const BayInfo*>(
               &_BayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BayInfo* other);
  friend void swap(BayInfo& a, BayInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BayInfo* New() const final {
    return CreateMaybeMessage<BayInfo>(NULL);
  }

  BayInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BayInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BayInfo& from);
  void MergeFrom(const BayInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bay = 1;
  bool has_bay() const;
  void clear_bay();
  static const int kBayFieldNumber = 1;
  ::google::protobuf::int32 bay() const;
  void set_bay(::google::protobuf::int32 value);

  // optional int32 row = 2;
  bool has_row() const;
  void clear_row();
  static const int kRowFieldNumber = 2;
  ::google::protobuf::int32 row() const;
  void set_row(::google::protobuf::int32 value);

  // optional bool hasBox = 3;
  bool has_hasbox() const;
  void clear_hasbox();
  static const int kHasBoxFieldNumber = 3;
  bool hasbox() const;
  void set_hasbox(bool value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BayInfo)
 private:
  void set_has_bay();
  void clear_has_bay();
  void set_has_row();
  void clear_has_row();
  void set_has_hasbox();
  void clear_has_hasbox();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 bay_;
  ::google::protobuf::int32 row_;
  bool hasbox_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockBoxInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BlockBoxInfo) */ {
 public:
  BlockBoxInfo();
  virtual ~BlockBoxInfo();

  BlockBoxInfo(const BlockBoxInfo& from);

  inline BlockBoxInfo& operator=(const BlockBoxInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockBoxInfo(BlockBoxInfo&& from) noexcept
    : BlockBoxInfo() {
    *this = ::std::move(from);
  }

  inline BlockBoxInfo& operator=(BlockBoxInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BlockBoxInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockBoxInfo* internal_default_instance() {
    return reinterpret_cast<const BlockBoxInfo*>(
               &_BlockBoxInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BlockBoxInfo* other);
  friend void swap(BlockBoxInfo& a, BlockBoxInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockBoxInfo* New() const final {
    return CreateMaybeMessage<BlockBoxInfo>(NULL);
  }

  BlockBoxInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockBoxInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BlockBoxInfo& from);
  void MergeFrom(const BlockBoxInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockBoxInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.BayInfo blockBigBayList = 1;
  int blockbigbaylist_size() const;
  void clear_blockbigbaylist();
  static const int kBlockBigBayListFieldNumber = 1;
  ::atd::taskmanager::fusion::BayInfo* mutable_blockbigbaylist(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >*
      mutable_blockbigbaylist();
  const ::atd::taskmanager::fusion::BayInfo& blockbigbaylist(int index) const;
  ::atd::taskmanager::fusion::BayInfo* add_blockbigbaylist();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >&
      blockbigbaylist() const;

  // repeated .atd.taskmanager.fusion.BayInfo blockSmallBayList = 2;
  int blocksmallbaylist_size() const;
  void clear_blocksmallbaylist();
  static const int kBlockSmallBayListFieldNumber = 2;
  ::atd::taskmanager::fusion::BayInfo* mutable_blocksmallbaylist(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >*
      mutable_blocksmallbaylist();
  const ::atd::taskmanager::fusion::BayInfo& blocksmallbaylist(int index) const;
  ::atd::taskmanager::fusion::BayInfo* add_blocksmallbaylist();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >&
      blocksmallbaylist() const;

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BlockBoxInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo > blockbigbaylist_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo > blocksmallbaylist_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockObstacleInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BlockObstacleInfo) */ {
 public:
  BlockObstacleInfo();
  virtual ~BlockObstacleInfo();

  BlockObstacleInfo(const BlockObstacleInfo& from);

  inline BlockObstacleInfo& operator=(const BlockObstacleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockObstacleInfo(BlockObstacleInfo&& from) noexcept
    : BlockObstacleInfo() {
    *this = ::std::move(from);
  }

  inline BlockObstacleInfo& operator=(BlockObstacleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BlockObstacleInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockObstacleInfo* internal_default_instance() {
    return reinterpret_cast<const BlockObstacleInfo*>(
               &_BlockObstacleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlockObstacleInfo* other);
  friend void swap(BlockObstacleInfo& a, BlockObstacleInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockObstacleInfo* New() const final {
    return CreateMaybeMessage<BlockObstacleInfo>(NULL);
  }

  BlockObstacleInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockObstacleInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BlockObstacleInfo& from);
  void MergeFrom(const BlockObstacleInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockObstacleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.BlockRtgInfo blockRtgInfo = 3;
  int blockrtginfo_size() const;
  void clear_blockrtginfo();
  static const int kBlockRtgInfoFieldNumber = 3;
  ::atd::taskmanager::fusion::BlockRtgInfo* mutable_blockrtginfo(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BlockRtgInfo >*
      mutable_blockrtginfo();
  const ::atd::taskmanager::fusion::BlockRtgInfo& blockrtginfo(int index) const;
  ::atd::taskmanager::fusion::BlockRtgInfo* add_blockrtginfo();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BlockRtgInfo >&
      blockrtginfo() const;

  // optional .atd.taskmanager.fusion.BlockBoxInfo blockBoxInfo = 4;
  bool has_blockboxinfo() const;
  void clear_blockboxinfo();
  static const int kBlockBoxInfoFieldNumber = 4;
  private:
  const ::atd::taskmanager::fusion::BlockBoxInfo& _internal_blockboxinfo() const;
  public:
  const ::atd::taskmanager::fusion::BlockBoxInfo& blockboxinfo() const;
  ::atd::taskmanager::fusion::BlockBoxInfo* release_blockboxinfo();
  ::atd::taskmanager::fusion::BlockBoxInfo* mutable_blockboxinfo();
  void set_allocated_blockboxinfo(::atd::taskmanager::fusion::BlockBoxInfo* blockboxinfo);

  // optional int32 blockNo = 1;
  bool has_blockno() const;
  void clear_blockno();
  static const int kBlockNoFieldNumber = 1;
  ::google::protobuf::int32 blockno() const;
  void set_blockno(::google::protobuf::int32 value);

  // optional int32 driveType = 2;
  bool has_drivetype() const;
  void clear_drivetype();
  static const int kDriveTypeFieldNumber = 2;
  ::google::protobuf::int32 drivetype() const;
  void set_drivetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BlockObstacleInfo)
 private:
  void set_has_blockno();
  void clear_has_blockno();
  void set_has_drivetype();
  void clear_has_drivetype();
  void set_has_blockboxinfo();
  void clear_has_blockboxinfo();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BlockRtgInfo > blockrtginfo_;
  ::atd::taskmanager::fusion::BlockBoxInfo* blockboxinfo_;
  ::google::protobuf::int32 blockno_;
  ::google::protobuf::int32 drivetype_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BrigeQcInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BrigeQcInfo) */ {
 public:
  BrigeQcInfo();
  virtual ~BrigeQcInfo();

  BrigeQcInfo(const BrigeQcInfo& from);

  inline BrigeQcInfo& operator=(const BrigeQcInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BrigeQcInfo(BrigeQcInfo&& from) noexcept
    : BrigeQcInfo() {
    *this = ::std::move(from);
  }

  inline BrigeQcInfo& operator=(BrigeQcInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BrigeQcInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrigeQcInfo* internal_default_instance() {
    return reinterpret_cast<const BrigeQcInfo*>(
               &_BrigeQcInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BrigeQcInfo* other);
  friend void swap(BrigeQcInfo& a, BrigeQcInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BrigeQcInfo* New() const final {
    return CreateMaybeMessage<BrigeQcInfo>(NULL);
  }

  BrigeQcInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BrigeQcInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BrigeQcInfo& from);
  void MergeFrom(const BrigeQcInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrigeQcInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.Point qcScopeCoordinate = 4;
  int qcscopecoordinate_size() const;
  void clear_qcscopecoordinate();
  static const int kQcScopeCoordinateFieldNumber = 4;
  ::atd::taskmanager::fusion::Point* mutable_qcscopecoordinate(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
      mutable_qcscopecoordinate();
  const ::atd::taskmanager::fusion::Point& qcscopecoordinate(int index) const;
  ::atd::taskmanager::fusion::Point* add_qcscopecoordinate();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
      qcscopecoordinate() const;

  // optional string qcNo = 1;
  bool has_qcno() const;
  void clear_qcno();
  static const int kQcNoFieldNumber = 1;
  const ::std::string& qcno() const;
  void set_qcno(const ::std::string& value);
  #if LANG_CXX11
  void set_qcno(::std::string&& value);
  #endif
  void set_qcno(const char* value);
  void set_qcno(const char* value, size_t size);
  ::std::string* mutable_qcno();
  ::std::string* release_qcno();
  void set_allocated_qcno(::std::string* qcno);

  // optional .atd.taskmanager.fusion.Point qcCenterPos = 3;
  bool has_qccenterpos() const;
  void clear_qccenterpos();
  static const int kQcCenterPosFieldNumber = 3;
  private:
  const ::atd::taskmanager::fusion::Point& _internal_qccenterpos() const;
  public:
  const ::atd::taskmanager::fusion::Point& qccenterpos() const;
  ::atd::taskmanager::fusion::Point* release_qccenterpos();
  ::atd::taskmanager::fusion::Point* mutable_qccenterpos();
  void set_allocated_qccenterpos(::atd::taskmanager::fusion::Point* qccenterpos);

  // optional double qcHeading = 2;
  bool has_qcheading() const;
  void clear_qcheading();
  static const int kQcHeadingFieldNumber = 2;
  double qcheading() const;
  void set_qcheading(double value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BrigeQcInfo)
 private:
  void set_has_qcno();
  void clear_has_qcno();
  void set_has_qcheading();
  void clear_has_qcheading();
  void set_has_qccenterpos();
  void clear_has_qccenterpos();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point > qcscopecoordinate_;
  ::google::protobuf::internal::ArenaStringPtr qcno_;
  ::atd::taskmanager::fusion::Point* qccenterpos_;
  double qcheading_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BrigeInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.BrigeInfo) */ {
 public:
  BrigeInfo();
  virtual ~BrigeInfo();

  BrigeInfo(const BrigeInfo& from);

  inline BrigeInfo& operator=(const BrigeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BrigeInfo(BrigeInfo&& from) noexcept
    : BrigeInfo() {
    *this = ::std::move(from);
  }

  inline BrigeInfo& operator=(BrigeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BrigeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BrigeInfo* internal_default_instance() {
    return reinterpret_cast<const BrigeInfo*>(
               &_BrigeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BrigeInfo* other);
  friend void swap(BrigeInfo& a, BrigeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BrigeInfo* New() const final {
    return CreateMaybeMessage<BrigeInfo>(NULL);
  }

  BrigeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BrigeInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BrigeInfo& from);
  void MergeFrom(const BrigeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrigeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.BrigeQcInfo qcInfo = 2;
  int qcinfo_size() const;
  void clear_qcinfo();
  static const int kQcInfoFieldNumber = 2;
  ::atd::taskmanager::fusion::BrigeQcInfo* mutable_qcinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BrigeQcInfo >*
      mutable_qcinfo();
  const ::atd::taskmanager::fusion::BrigeQcInfo& qcinfo(int index) const;
  ::atd::taskmanager::fusion::BrigeQcInfo* add_qcinfo();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BrigeQcInfo >&
      qcinfo() const;

  // optional bool enable = 1;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.BrigeInfo)
 private:
  void set_has_enable();
  void clear_has_enable();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BrigeQcInfo > qcinfo_;
  bool enable_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskManager2Fusion : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.TaskManager2Fusion) */ {
 public:
  TaskManager2Fusion();
  virtual ~TaskManager2Fusion();

  TaskManager2Fusion(const TaskManager2Fusion& from);

  inline TaskManager2Fusion& operator=(const TaskManager2Fusion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskManager2Fusion(TaskManager2Fusion&& from) noexcept
    : TaskManager2Fusion() {
    *this = ::std::move(from);
  }

  inline TaskManager2Fusion& operator=(TaskManager2Fusion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TaskManager2Fusion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskManager2Fusion* internal_default_instance() {
    return reinterpret_cast<const TaskManager2Fusion*>(
               &_TaskManager2Fusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TaskManager2Fusion* other);
  friend void swap(TaskManager2Fusion& a, TaskManager2Fusion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskManager2Fusion* New() const final {
    return CreateMaybeMessage<TaskManager2Fusion>(NULL);
  }

  TaskManager2Fusion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskManager2Fusion>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const TaskManager2Fusion& from);
  void MergeFrom(const TaskManager2Fusion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskManager2Fusion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atd.taskmanager.fusion.BlockObstacleInfo blockObstacleInfo = 1;
  bool has_blockobstacleinfo() const;
  void clear_blockobstacleinfo();
  static const int kBlockObstacleInfoFieldNumber = 1;
  private:
  const ::atd::taskmanager::fusion::BlockObstacleInfo& _internal_blockobstacleinfo() const;
  public:
  const ::atd::taskmanager::fusion::BlockObstacleInfo& blockobstacleinfo() const;
  ::atd::taskmanager::fusion::BlockObstacleInfo* release_blockobstacleinfo();
  ::atd::taskmanager::fusion::BlockObstacleInfo* mutable_blockobstacleinfo();
  void set_allocated_blockobstacleinfo(::atd::taskmanager::fusion::BlockObstacleInfo* blockobstacleinfo);

  // optional .atd.taskmanager.fusion.BrigeInfo brigeInfo = 2;
  bool has_brigeinfo() const;
  void clear_brigeinfo();
  static const int kBrigeInfoFieldNumber = 2;
  private:
  const ::atd::taskmanager::fusion::BrigeInfo& _internal_brigeinfo() const;
  public:
  const ::atd::taskmanager::fusion::BrigeInfo& brigeinfo() const;
  ::atd::taskmanager::fusion::BrigeInfo* release_brigeinfo();
  ::atd::taskmanager::fusion::BrigeInfo* mutable_brigeinfo();
  void set_allocated_brigeinfo(::atd::taskmanager::fusion::BrigeInfo* brigeinfo);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.TaskManager2Fusion)
 private:
  void set_has_blockobstacleinfo();
  void clear_has_blockobstacleinfo();
  void set_has_brigeinfo();
  void clear_has_brigeinfo();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::atd::taskmanager::fusion::BlockObstacleInfo* blockobstacleinfo_;
  ::atd::taskmanager::fusion::BrigeInfo* brigeinfo_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.RouteInfo) */ {
 public:
  RouteInfo();
  virtual ~RouteInfo();

  RouteInfo(const RouteInfo& from);

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteInfo(RouteInfo&& from) noexcept
    : RouteInfo() {
    *this = ::std::move(from);
  }

  inline RouteInfo& operator=(RouteInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RouteInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteInfo* internal_default_instance() {
    return reinterpret_cast<const RouteInfo*>(
               &_RouteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RouteInfo* other);
  friend void swap(RouteInfo& a, RouteInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteInfo* New() const final {
    return CreateMaybeMessage<RouteInfo>(NULL);
  }

  RouteInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RouteInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RouteInfo& from);
  void MergeFrom(const RouteInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouteInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.Point route = 5;
  int route_size() const;
  void clear_route();
  static const int kRouteFieldNumber = 5;
  ::atd::taskmanager::fusion::Point* mutable_route(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
      mutable_route();
  const ::atd::taskmanager::fusion::Point& route(int index) const;
  ::atd::taskmanager::fusion::Point* add_route();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
      route() const;

  // repeated double axisAngle = 11;
  int axisangle_size() const;
  void clear_axisangle();
  static const int kAxisAngleFieldNumber = 11;
  double axisangle(int index) const;
  void set_axisangle(int index, double value);
  void add_axisangle(double value);
  const ::google::protobuf::RepeatedField< double >&
      axisangle() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_axisangle();

  // optional string vehicleId = 1;
  bool has_vehicleid() const;
  void clear_vehicleid();
  static const int kVehicleIdFieldNumber = 1;
  const ::std::string& vehicleid() const;
  void set_vehicleid(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicleid(::std::string&& value);
  #endif
  void set_vehicleid(const char* value);
  void set_vehicleid(const char* value, size_t size);
  ::std::string* mutable_vehicleid();
  ::std::string* release_vehicleid();
  void set_allocated_vehicleid(::std::string* vehicleid);

  // optional string vehicleType = 2;
  bool has_vehicletype() const;
  void clear_vehicletype();
  static const int kVehicleTypeFieldNumber = 2;
  const ::std::string& vehicletype() const;
  void set_vehicletype(const ::std::string& value);
  #if LANG_CXX11
  void set_vehicletype(::std::string&& value);
  #endif
  void set_vehicletype(const char* value);
  void set_vehicletype(const char* value, size_t size);
  ::std::string* mutable_vehicletype();
  ::std::string* release_vehicletype();
  void set_allocated_vehicletype(::std::string* vehicletype);

  // optional .atd.taskmanager.fusion.Point centerCoordinate = 3;
  bool has_centercoordinate() const;
  void clear_centercoordinate();
  static const int kCenterCoordinateFieldNumber = 3;
  private:
  const ::atd::taskmanager::fusion::Point& _internal_centercoordinate() const;
  public:
  const ::atd::taskmanager::fusion::Point& centercoordinate() const;
  ::atd::taskmanager::fusion::Point* release_centercoordinate();
  ::atd::taskmanager::fusion::Point* mutable_centercoordinate();
  void set_allocated_centercoordinate(::atd::taskmanager::fusion::Point* centercoordinate);

  // optional int64 coordinateTime = 4;
  bool has_coordinatetime() const;
  void clear_coordinatetime();
  static const int kCoordinateTimeFieldNumber = 4;
  ::google::protobuf::int64 coordinatetime() const;
  void set_coordinatetime(::google::protobuf::int64 value);

  // optional int64 routeTime = 6;
  bool has_routetime() const;
  void clear_routetime();
  static const int kRouteTimeFieldNumber = 6;
  ::google::protobuf::int64 routetime() const;
  void set_routetime(::google::protobuf::int64 value);

  // optional float speed = 7;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 7;
  float speed() const;
  void set_speed(float value);

  // optional float heading = 8;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 8;
  float heading() const;
  void set_heading(float value);

  // optional int32 workingMode = 9;
  bool has_workingmode() const;
  void clear_workingmode();
  static const int kWorkingModeFieldNumber = 9;
  ::google::protobuf::int32 workingmode() const;
  void set_workingmode(::google::protobuf::int32 value);

  // optional int32 taskType = 10;
  bool has_tasktype() const;
  void clear_tasktype();
  static const int kTaskTypeFieldNumber = 10;
  ::google::protobuf::int32 tasktype() const;
  void set_tasktype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.RouteInfo)
 private:
  void set_has_vehicleid();
  void clear_has_vehicleid();
  void set_has_vehicletype();
  void clear_has_vehicletype();
  void set_has_centercoordinate();
  void clear_has_centercoordinate();
  void set_has_coordinatetime();
  void clear_has_coordinatetime();
  void set_has_routetime();
  void clear_has_routetime();
  void set_has_speed();
  void clear_has_speed();
  void set_has_heading();
  void clear_has_heading();
  void set_has_workingmode();
  void clear_has_workingmode();
  void set_has_tasktype();
  void clear_has_tasktype();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point > route_;
  ::google::protobuf::RepeatedField< double > axisangle_;
  ::google::protobuf::internal::ArenaStringPtr vehicleid_;
  ::google::protobuf::internal::ArenaStringPtr vehicletype_;
  ::atd::taskmanager::fusion::Point* centercoordinate_;
  ::google::protobuf::int64 coordinatetime_;
  ::google::protobuf::int64 routetime_;
  float speed_;
  float heading_;
  ::google::protobuf::int32 workingmode_;
  ::google::protobuf::int32 tasktype_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultipleVehiclesRoutes : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:atd.taskmanager.fusion.MultipleVehiclesRoutes) */ {
 public:
  MultipleVehiclesRoutes();
  virtual ~MultipleVehiclesRoutes();

  MultipleVehiclesRoutes(const MultipleVehiclesRoutes& from);

  inline MultipleVehiclesRoutes& operator=(const MultipleVehiclesRoutes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultipleVehiclesRoutes(MultipleVehiclesRoutes&& from) noexcept
    : MultipleVehiclesRoutes() {
    *this = ::std::move(from);
  }

  inline MultipleVehiclesRoutes& operator=(MultipleVehiclesRoutes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MultipleVehiclesRoutes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultipleVehiclesRoutes* internal_default_instance() {
    return reinterpret_cast<const MultipleVehiclesRoutes*>(
               &_MultipleVehiclesRoutes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MultipleVehiclesRoutes* other);
  friend void swap(MultipleVehiclesRoutes& a, MultipleVehiclesRoutes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultipleVehiclesRoutes* New() const final {
    return CreateMaybeMessage<MultipleVehiclesRoutes>(NULL);
  }

  MultipleVehiclesRoutes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultipleVehiclesRoutes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MultipleVehiclesRoutes& from);
  void MergeFrom(const MultipleVehiclesRoutes& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultipleVehiclesRoutes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .atd.taskmanager.fusion.RouteInfo MultipleVehiclesRoutes = 2;
  int multiplevehiclesroutes_size() const;
  void clear_multiplevehiclesroutes();
  static const int kMultipleVehiclesRoutesFieldNumber = 2;
  ::atd::taskmanager::fusion::RouteInfo* mutable_multiplevehiclesroutes(int index);
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::RouteInfo >*
      mutable_multiplevehiclesroutes();
  const ::atd::taskmanager::fusion::RouteInfo& multiplevehiclesroutes(int index) const;
  ::atd::taskmanager::fusion::RouteInfo* add_multiplevehiclesroutes();
  const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::RouteInfo >&
      multiplevehiclesroutes() const;

  // optional int64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:atd.taskmanager.fusion.MultipleVehiclesRoutes)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::RouteInfo > multiplevehiclesroutes_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_taskmanager_5ffusion_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// optional double longitude = 1;
inline bool Point::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Point::longitude() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.Point.longitude)
  return longitude_;
}
inline void Point::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.Point.longitude)
}

// optional double latitude = 2;
inline bool Point::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Point::latitude() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.Point.latitude)
  return latitude_;
}
inline void Point::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.Point.latitude)
}

// -------------------------------------------------------------------

// BlockRtgInfo

// optional string rtgNo = 1;
inline bool BlockRtgInfo::has_rtgno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockRtgInfo::set_has_rtgno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockRtgInfo::clear_has_rtgno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockRtgInfo::clear_rtgno() {
  rtgno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rtgno();
}
inline const ::std::string& BlockRtgInfo::rtgno() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
  return rtgno_.GetNoArena();
}
inline void BlockRtgInfo::set_rtgno(const ::std::string& value) {
  set_has_rtgno();
  rtgno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
}
#if LANG_CXX11
inline void BlockRtgInfo::set_rtgno(::std::string&& value) {
  set_has_rtgno();
  rtgno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
}
#endif
inline void BlockRtgInfo::set_rtgno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rtgno();
  rtgno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
}
inline void BlockRtgInfo::set_rtgno(const char* value, size_t size) {
  set_has_rtgno();
  rtgno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
}
inline ::std::string* BlockRtgInfo::mutable_rtgno() {
  set_has_rtgno();
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
  return rtgno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockRtgInfo::release_rtgno() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
  if (!has_rtgno()) {
    return NULL;
  }
  clear_has_rtgno();
  return rtgno_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockRtgInfo::set_allocated_rtgno(::std::string* rtgno) {
  if (rtgno != NULL) {
    set_has_rtgno();
  } else {
    clear_has_rtgno();
  }
  rtgno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rtgno);
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.BlockRtgInfo.rtgNo)
}

// optional .atd.taskmanager.fusion.Point rtgCenterPos = 2;
inline bool BlockRtgInfo::has_rtgcenterpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockRtgInfo::set_has_rtgcenterpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockRtgInfo::clear_has_rtgcenterpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockRtgInfo::clear_rtgcenterpos() {
  if (rtgcenterpos_ != NULL) rtgcenterpos_->Clear();
  clear_has_rtgcenterpos();
}
inline const ::atd::taskmanager::fusion::Point& BlockRtgInfo::_internal_rtgcenterpos() const {
  return *rtgcenterpos_;
}
inline const ::atd::taskmanager::fusion::Point& BlockRtgInfo::rtgcenterpos() const {
  const ::atd::taskmanager::fusion::Point* p = rtgcenterpos_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockRtgInfo.rtgCenterPos)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::Point*>(
      &::atd::taskmanager::fusion::_Point_default_instance_);
}
inline ::atd::taskmanager::fusion::Point* BlockRtgInfo::release_rtgcenterpos() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.BlockRtgInfo.rtgCenterPos)
  clear_has_rtgcenterpos();
  ::atd::taskmanager::fusion::Point* temp = rtgcenterpos_;
  rtgcenterpos_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::Point* BlockRtgInfo::mutable_rtgcenterpos() {
  set_has_rtgcenterpos();
  if (rtgcenterpos_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::Point>(GetArenaNoVirtual());
    rtgcenterpos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockRtgInfo.rtgCenterPos)
  return rtgcenterpos_;
}
inline void BlockRtgInfo::set_allocated_rtgcenterpos(::atd::taskmanager::fusion::Point* rtgcenterpos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rtgcenterpos_;
  }
  if (rtgcenterpos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rtgcenterpos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rtgcenterpos, submessage_arena);
    }
    set_has_rtgcenterpos();
  } else {
    clear_has_rtgcenterpos();
  }
  rtgcenterpos_ = rtgcenterpos;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.BlockRtgInfo.rtgCenterPos)
}

// repeated .atd.taskmanager.fusion.Point rtgScopeCoordinate = 3;
inline int BlockRtgInfo::rtgscopecoordinate_size() const {
  return rtgscopecoordinate_.size();
}
inline void BlockRtgInfo::clear_rtgscopecoordinate() {
  rtgscopecoordinate_.Clear();
}
inline ::atd::taskmanager::fusion::Point* BlockRtgInfo::mutable_rtgscopecoordinate(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockRtgInfo.rtgScopeCoordinate)
  return rtgscopecoordinate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
BlockRtgInfo::mutable_rtgscopecoordinate() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BlockRtgInfo.rtgScopeCoordinate)
  return &rtgscopecoordinate_;
}
inline const ::atd::taskmanager::fusion::Point& BlockRtgInfo::rtgscopecoordinate(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockRtgInfo.rtgScopeCoordinate)
  return rtgscopecoordinate_.Get(index);
}
inline ::atd::taskmanager::fusion::Point* BlockRtgInfo::add_rtgscopecoordinate() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BlockRtgInfo.rtgScopeCoordinate)
  return rtgscopecoordinate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
BlockRtgInfo::rtgscopecoordinate() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BlockRtgInfo.rtgScopeCoordinate)
  return rtgscopecoordinate_;
}

// optional int64 nTimeStamp = 4;
inline bool BlockRtgInfo::has_ntimestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockRtgInfo::set_has_ntimestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockRtgInfo::clear_has_ntimestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockRtgInfo::clear_ntimestamp() {
  ntimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_ntimestamp();
}
inline ::google::protobuf::int64 BlockRtgInfo::ntimestamp() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockRtgInfo.nTimeStamp)
  return ntimestamp_;
}
inline void BlockRtgInfo::set_ntimestamp(::google::protobuf::int64 value) {
  set_has_ntimestamp();
  ntimestamp_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BlockRtgInfo.nTimeStamp)
}

// -------------------------------------------------------------------

// BayInfo

// optional int32 bay = 1;
inline bool BayInfo::has_bay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BayInfo::set_has_bay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BayInfo::clear_has_bay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BayInfo::clear_bay() {
  bay_ = 0;
  clear_has_bay();
}
inline ::google::protobuf::int32 BayInfo::bay() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BayInfo.bay)
  return bay_;
}
inline void BayInfo::set_bay(::google::protobuf::int32 value) {
  set_has_bay();
  bay_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BayInfo.bay)
}

// optional int32 row = 2;
inline bool BayInfo::has_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BayInfo::set_has_row() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BayInfo::clear_has_row() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BayInfo::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 BayInfo::row() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BayInfo.row)
  return row_;
}
inline void BayInfo::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BayInfo.row)
}

// optional bool hasBox = 3;
inline bool BayInfo::has_hasbox() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BayInfo::set_has_hasbox() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BayInfo::clear_has_hasbox() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BayInfo::clear_hasbox() {
  hasbox_ = false;
  clear_has_hasbox();
}
inline bool BayInfo::hasbox() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BayInfo.hasBox)
  return hasbox_;
}
inline void BayInfo::set_hasbox(bool value) {
  set_has_hasbox();
  hasbox_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BayInfo.hasBox)
}

// -------------------------------------------------------------------

// BlockBoxInfo

// repeated .atd.taskmanager.fusion.BayInfo blockBigBayList = 1;
inline int BlockBoxInfo::blockbigbaylist_size() const {
  return blockbigbaylist_.size();
}
inline void BlockBoxInfo::clear_blockbigbaylist() {
  blockbigbaylist_.Clear();
}
inline ::atd::taskmanager::fusion::BayInfo* BlockBoxInfo::mutable_blockbigbaylist(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockBoxInfo.blockBigBayList)
  return blockbigbaylist_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >*
BlockBoxInfo::mutable_blockbigbaylist() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BlockBoxInfo.blockBigBayList)
  return &blockbigbaylist_;
}
inline const ::atd::taskmanager::fusion::BayInfo& BlockBoxInfo::blockbigbaylist(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockBoxInfo.blockBigBayList)
  return blockbigbaylist_.Get(index);
}
inline ::atd::taskmanager::fusion::BayInfo* BlockBoxInfo::add_blockbigbaylist() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BlockBoxInfo.blockBigBayList)
  return blockbigbaylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >&
BlockBoxInfo::blockbigbaylist() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BlockBoxInfo.blockBigBayList)
  return blockbigbaylist_;
}

// repeated .atd.taskmanager.fusion.BayInfo blockSmallBayList = 2;
inline int BlockBoxInfo::blocksmallbaylist_size() const {
  return blocksmallbaylist_.size();
}
inline void BlockBoxInfo::clear_blocksmallbaylist() {
  blocksmallbaylist_.Clear();
}
inline ::atd::taskmanager::fusion::BayInfo* BlockBoxInfo::mutable_blocksmallbaylist(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockBoxInfo.blockSmallBayList)
  return blocksmallbaylist_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >*
BlockBoxInfo::mutable_blocksmallbaylist() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BlockBoxInfo.blockSmallBayList)
  return &blocksmallbaylist_;
}
inline const ::atd::taskmanager::fusion::BayInfo& BlockBoxInfo::blocksmallbaylist(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockBoxInfo.blockSmallBayList)
  return blocksmallbaylist_.Get(index);
}
inline ::atd::taskmanager::fusion::BayInfo* BlockBoxInfo::add_blocksmallbaylist() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BlockBoxInfo.blockSmallBayList)
  return blocksmallbaylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BayInfo >&
BlockBoxInfo::blocksmallbaylist() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BlockBoxInfo.blockSmallBayList)
  return blocksmallbaylist_;
}

// -------------------------------------------------------------------

// BlockObstacleInfo

// optional int32 blockNo = 1;
inline bool BlockObstacleInfo::has_blockno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockObstacleInfo::set_has_blockno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockObstacleInfo::clear_has_blockno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockObstacleInfo::clear_blockno() {
  blockno_ = 0;
  clear_has_blockno();
}
inline ::google::protobuf::int32 BlockObstacleInfo::blockno() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockObstacleInfo.blockNo)
  return blockno_;
}
inline void BlockObstacleInfo::set_blockno(::google::protobuf::int32 value) {
  set_has_blockno();
  blockno_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BlockObstacleInfo.blockNo)
}

// optional int32 driveType = 2;
inline bool BlockObstacleInfo::has_drivetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockObstacleInfo::set_has_drivetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockObstacleInfo::clear_has_drivetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockObstacleInfo::clear_drivetype() {
  drivetype_ = 0;
  clear_has_drivetype();
}
inline ::google::protobuf::int32 BlockObstacleInfo::drivetype() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockObstacleInfo.driveType)
  return drivetype_;
}
inline void BlockObstacleInfo::set_drivetype(::google::protobuf::int32 value) {
  set_has_drivetype();
  drivetype_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BlockObstacleInfo.driveType)
}

// repeated .atd.taskmanager.fusion.BlockRtgInfo blockRtgInfo = 3;
inline int BlockObstacleInfo::blockrtginfo_size() const {
  return blockrtginfo_.size();
}
inline void BlockObstacleInfo::clear_blockrtginfo() {
  blockrtginfo_.Clear();
}
inline ::atd::taskmanager::fusion::BlockRtgInfo* BlockObstacleInfo::mutable_blockrtginfo(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockObstacleInfo.blockRtgInfo)
  return blockrtginfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BlockRtgInfo >*
BlockObstacleInfo::mutable_blockrtginfo() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BlockObstacleInfo.blockRtgInfo)
  return &blockrtginfo_;
}
inline const ::atd::taskmanager::fusion::BlockRtgInfo& BlockObstacleInfo::blockrtginfo(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockObstacleInfo.blockRtgInfo)
  return blockrtginfo_.Get(index);
}
inline ::atd::taskmanager::fusion::BlockRtgInfo* BlockObstacleInfo::add_blockrtginfo() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BlockObstacleInfo.blockRtgInfo)
  return blockrtginfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BlockRtgInfo >&
BlockObstacleInfo::blockrtginfo() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BlockObstacleInfo.blockRtgInfo)
  return blockrtginfo_;
}

// optional .atd.taskmanager.fusion.BlockBoxInfo blockBoxInfo = 4;
inline bool BlockObstacleInfo::has_blockboxinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockObstacleInfo::set_has_blockboxinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockObstacleInfo::clear_has_blockboxinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockObstacleInfo::clear_blockboxinfo() {
  if (blockboxinfo_ != NULL) blockboxinfo_->Clear();
  clear_has_blockboxinfo();
}
inline const ::atd::taskmanager::fusion::BlockBoxInfo& BlockObstacleInfo::_internal_blockboxinfo() const {
  return *blockboxinfo_;
}
inline const ::atd::taskmanager::fusion::BlockBoxInfo& BlockObstacleInfo::blockboxinfo() const {
  const ::atd::taskmanager::fusion::BlockBoxInfo* p = blockboxinfo_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BlockObstacleInfo.blockBoxInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::BlockBoxInfo*>(
      &::atd::taskmanager::fusion::_BlockBoxInfo_default_instance_);
}
inline ::atd::taskmanager::fusion::BlockBoxInfo* BlockObstacleInfo::release_blockboxinfo() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.BlockObstacleInfo.blockBoxInfo)
  clear_has_blockboxinfo();
  ::atd::taskmanager::fusion::BlockBoxInfo* temp = blockboxinfo_;
  blockboxinfo_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::BlockBoxInfo* BlockObstacleInfo::mutable_blockboxinfo() {
  set_has_blockboxinfo();
  if (blockboxinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::BlockBoxInfo>(GetArenaNoVirtual());
    blockboxinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BlockObstacleInfo.blockBoxInfo)
  return blockboxinfo_;
}
inline void BlockObstacleInfo::set_allocated_blockboxinfo(::atd::taskmanager::fusion::BlockBoxInfo* blockboxinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blockboxinfo_;
  }
  if (blockboxinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blockboxinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blockboxinfo, submessage_arena);
    }
    set_has_blockboxinfo();
  } else {
    clear_has_blockboxinfo();
  }
  blockboxinfo_ = blockboxinfo;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.BlockObstacleInfo.blockBoxInfo)
}

// -------------------------------------------------------------------

// BrigeQcInfo

// optional string qcNo = 1;
inline bool BrigeQcInfo::has_qcno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrigeQcInfo::set_has_qcno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrigeQcInfo::clear_has_qcno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrigeQcInfo::clear_qcno() {
  qcno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qcno();
}
inline const ::std::string& BrigeQcInfo::qcno() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
  return qcno_.GetNoArena();
}
inline void BrigeQcInfo::set_qcno(const ::std::string& value) {
  set_has_qcno();
  qcno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
}
#if LANG_CXX11
inline void BrigeQcInfo::set_qcno(::std::string&& value) {
  set_has_qcno();
  qcno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
}
#endif
inline void BrigeQcInfo::set_qcno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_qcno();
  qcno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
}
inline void BrigeQcInfo::set_qcno(const char* value, size_t size) {
  set_has_qcno();
  qcno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
}
inline ::std::string* BrigeQcInfo::mutable_qcno() {
  set_has_qcno();
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
  return qcno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BrigeQcInfo::release_qcno() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
  if (!has_qcno()) {
    return NULL;
  }
  clear_has_qcno();
  return qcno_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BrigeQcInfo::set_allocated_qcno(::std::string* qcno) {
  if (qcno != NULL) {
    set_has_qcno();
  } else {
    clear_has_qcno();
  }
  qcno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qcno);
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.BrigeQcInfo.qcNo)
}

// optional double qcHeading = 2;
inline bool BrigeQcInfo::has_qcheading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrigeQcInfo::set_has_qcheading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrigeQcInfo::clear_has_qcheading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrigeQcInfo::clear_qcheading() {
  qcheading_ = 0;
  clear_has_qcheading();
}
inline double BrigeQcInfo::qcheading() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeQcInfo.qcHeading)
  return qcheading_;
}
inline void BrigeQcInfo::set_qcheading(double value) {
  set_has_qcheading();
  qcheading_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BrigeQcInfo.qcHeading)
}

// optional .atd.taskmanager.fusion.Point qcCenterPos = 3;
inline bool BrigeQcInfo::has_qccenterpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrigeQcInfo::set_has_qccenterpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrigeQcInfo::clear_has_qccenterpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrigeQcInfo::clear_qccenterpos() {
  if (qccenterpos_ != NULL) qccenterpos_->Clear();
  clear_has_qccenterpos();
}
inline const ::atd::taskmanager::fusion::Point& BrigeQcInfo::_internal_qccenterpos() const {
  return *qccenterpos_;
}
inline const ::atd::taskmanager::fusion::Point& BrigeQcInfo::qccenterpos() const {
  const ::atd::taskmanager::fusion::Point* p = qccenterpos_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeQcInfo.qcCenterPos)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::Point*>(
      &::atd::taskmanager::fusion::_Point_default_instance_);
}
inline ::atd::taskmanager::fusion::Point* BrigeQcInfo::release_qccenterpos() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.BrigeQcInfo.qcCenterPos)
  clear_has_qccenterpos();
  ::atd::taskmanager::fusion::Point* temp = qccenterpos_;
  qccenterpos_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::Point* BrigeQcInfo::mutable_qccenterpos() {
  set_has_qccenterpos();
  if (qccenterpos_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::Point>(GetArenaNoVirtual());
    qccenterpos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BrigeQcInfo.qcCenterPos)
  return qccenterpos_;
}
inline void BrigeQcInfo::set_allocated_qccenterpos(::atd::taskmanager::fusion::Point* qccenterpos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete qccenterpos_;
  }
  if (qccenterpos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      qccenterpos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, qccenterpos, submessage_arena);
    }
    set_has_qccenterpos();
  } else {
    clear_has_qccenterpos();
  }
  qccenterpos_ = qccenterpos;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.BrigeQcInfo.qcCenterPos)
}

// repeated .atd.taskmanager.fusion.Point qcScopeCoordinate = 4;
inline int BrigeQcInfo::qcscopecoordinate_size() const {
  return qcscopecoordinate_.size();
}
inline void BrigeQcInfo::clear_qcscopecoordinate() {
  qcscopecoordinate_.Clear();
}
inline ::atd::taskmanager::fusion::Point* BrigeQcInfo::mutable_qcscopecoordinate(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BrigeQcInfo.qcScopeCoordinate)
  return qcscopecoordinate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
BrigeQcInfo::mutable_qcscopecoordinate() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BrigeQcInfo.qcScopeCoordinate)
  return &qcscopecoordinate_;
}
inline const ::atd::taskmanager::fusion::Point& BrigeQcInfo::qcscopecoordinate(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeQcInfo.qcScopeCoordinate)
  return qcscopecoordinate_.Get(index);
}
inline ::atd::taskmanager::fusion::Point* BrigeQcInfo::add_qcscopecoordinate() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BrigeQcInfo.qcScopeCoordinate)
  return qcscopecoordinate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
BrigeQcInfo::qcscopecoordinate() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BrigeQcInfo.qcScopeCoordinate)
  return qcscopecoordinate_;
}

// -------------------------------------------------------------------

// BrigeInfo

// optional bool enable = 1;
inline bool BrigeInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrigeInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrigeInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrigeInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool BrigeInfo::enable() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeInfo.enable)
  return enable_;
}
inline void BrigeInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.BrigeInfo.enable)
}

// repeated .atd.taskmanager.fusion.BrigeQcInfo qcInfo = 2;
inline int BrigeInfo::qcinfo_size() const {
  return qcinfo_.size();
}
inline void BrigeInfo::clear_qcinfo() {
  qcinfo_.Clear();
}
inline ::atd::taskmanager::fusion::BrigeQcInfo* BrigeInfo::mutable_qcinfo(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.BrigeInfo.qcInfo)
  return qcinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BrigeQcInfo >*
BrigeInfo::mutable_qcinfo() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.BrigeInfo.qcInfo)
  return &qcinfo_;
}
inline const ::atd::taskmanager::fusion::BrigeQcInfo& BrigeInfo::qcinfo(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.BrigeInfo.qcInfo)
  return qcinfo_.Get(index);
}
inline ::atd::taskmanager::fusion::BrigeQcInfo* BrigeInfo::add_qcinfo() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.BrigeInfo.qcInfo)
  return qcinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::BrigeQcInfo >&
BrigeInfo::qcinfo() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.BrigeInfo.qcInfo)
  return qcinfo_;
}

// -------------------------------------------------------------------

// TaskManager2Fusion

// optional .atd.taskmanager.fusion.BlockObstacleInfo blockObstacleInfo = 1;
inline bool TaskManager2Fusion::has_blockobstacleinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskManager2Fusion::set_has_blockobstacleinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskManager2Fusion::clear_has_blockobstacleinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskManager2Fusion::clear_blockobstacleinfo() {
  if (blockobstacleinfo_ != NULL) blockobstacleinfo_->Clear();
  clear_has_blockobstacleinfo();
}
inline const ::atd::taskmanager::fusion::BlockObstacleInfo& TaskManager2Fusion::_internal_blockobstacleinfo() const {
  return *blockobstacleinfo_;
}
inline const ::atd::taskmanager::fusion::BlockObstacleInfo& TaskManager2Fusion::blockobstacleinfo() const {
  const ::atd::taskmanager::fusion::BlockObstacleInfo* p = blockobstacleinfo_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.TaskManager2Fusion.blockObstacleInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::BlockObstacleInfo*>(
      &::atd::taskmanager::fusion::_BlockObstacleInfo_default_instance_);
}
inline ::atd::taskmanager::fusion::BlockObstacleInfo* TaskManager2Fusion::release_blockobstacleinfo() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.TaskManager2Fusion.blockObstacleInfo)
  clear_has_blockobstacleinfo();
  ::atd::taskmanager::fusion::BlockObstacleInfo* temp = blockobstacleinfo_;
  blockobstacleinfo_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::BlockObstacleInfo* TaskManager2Fusion::mutable_blockobstacleinfo() {
  set_has_blockobstacleinfo();
  if (blockobstacleinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::BlockObstacleInfo>(GetArenaNoVirtual());
    blockobstacleinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.TaskManager2Fusion.blockObstacleInfo)
  return blockobstacleinfo_;
}
inline void TaskManager2Fusion::set_allocated_blockobstacleinfo(::atd::taskmanager::fusion::BlockObstacleInfo* blockobstacleinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blockobstacleinfo_;
  }
  if (blockobstacleinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blockobstacleinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blockobstacleinfo, submessage_arena);
    }
    set_has_blockobstacleinfo();
  } else {
    clear_has_blockobstacleinfo();
  }
  blockobstacleinfo_ = blockobstacleinfo;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.TaskManager2Fusion.blockObstacleInfo)
}

// optional .atd.taskmanager.fusion.BrigeInfo brigeInfo = 2;
inline bool TaskManager2Fusion::has_brigeinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskManager2Fusion::set_has_brigeinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskManager2Fusion::clear_has_brigeinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskManager2Fusion::clear_brigeinfo() {
  if (brigeinfo_ != NULL) brigeinfo_->Clear();
  clear_has_brigeinfo();
}
inline const ::atd::taskmanager::fusion::BrigeInfo& TaskManager2Fusion::_internal_brigeinfo() const {
  return *brigeinfo_;
}
inline const ::atd::taskmanager::fusion::BrigeInfo& TaskManager2Fusion::brigeinfo() const {
  const ::atd::taskmanager::fusion::BrigeInfo* p = brigeinfo_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.TaskManager2Fusion.brigeInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::BrigeInfo*>(
      &::atd::taskmanager::fusion::_BrigeInfo_default_instance_);
}
inline ::atd::taskmanager::fusion::BrigeInfo* TaskManager2Fusion::release_brigeinfo() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.TaskManager2Fusion.brigeInfo)
  clear_has_brigeinfo();
  ::atd::taskmanager::fusion::BrigeInfo* temp = brigeinfo_;
  brigeinfo_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::BrigeInfo* TaskManager2Fusion::mutable_brigeinfo() {
  set_has_brigeinfo();
  if (brigeinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::BrigeInfo>(GetArenaNoVirtual());
    brigeinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.TaskManager2Fusion.brigeInfo)
  return brigeinfo_;
}
inline void TaskManager2Fusion::set_allocated_brigeinfo(::atd::taskmanager::fusion::BrigeInfo* brigeinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete brigeinfo_;
  }
  if (brigeinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      brigeinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, brigeinfo, submessage_arena);
    }
    set_has_brigeinfo();
  } else {
    clear_has_brigeinfo();
  }
  brigeinfo_ = brigeinfo;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.TaskManager2Fusion.brigeInfo)
}

// -------------------------------------------------------------------

// RouteInfo

// optional string vehicleId = 1;
inline bool RouteInfo::has_vehicleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteInfo::set_has_vehicleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteInfo::clear_has_vehicleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteInfo::clear_vehicleid() {
  vehicleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicleid();
}
inline const ::std::string& RouteInfo::vehicleid() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.vehicleId)
  return vehicleid_.GetNoArena();
}
inline void RouteInfo::set_vehicleid(const ::std::string& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.vehicleId)
}
#if LANG_CXX11
inline void RouteInfo::set_vehicleid(::std::string&& value) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.taskmanager.fusion.RouteInfo.vehicleId)
}
#endif
inline void RouteInfo::set_vehicleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.taskmanager.fusion.RouteInfo.vehicleId)
}
inline void RouteInfo::set_vehicleid(const char* value, size_t size) {
  set_has_vehicleid();
  vehicleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.taskmanager.fusion.RouteInfo.vehicleId)
}
inline ::std::string* RouteInfo::mutable_vehicleid() {
  set_has_vehicleid();
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.RouteInfo.vehicleId)
  return vehicleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteInfo::release_vehicleid() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.RouteInfo.vehicleId)
  if (!has_vehicleid()) {
    return NULL;
  }
  clear_has_vehicleid();
  return vehicleid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteInfo::set_allocated_vehicleid(::std::string* vehicleid) {
  if (vehicleid != NULL) {
    set_has_vehicleid();
  } else {
    clear_has_vehicleid();
  }
  vehicleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicleid);
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.RouteInfo.vehicleId)
}

// optional string vehicleType = 2;
inline bool RouteInfo::has_vehicletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteInfo::set_has_vehicletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteInfo::clear_has_vehicletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteInfo::clear_vehicletype() {
  vehicletype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicletype();
}
inline const ::std::string& RouteInfo::vehicletype() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.vehicleType)
  return vehicletype_.GetNoArena();
}
inline void RouteInfo::set_vehicletype(const ::std::string& value) {
  set_has_vehicletype();
  vehicletype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.vehicleType)
}
#if LANG_CXX11
inline void RouteInfo::set_vehicletype(::std::string&& value) {
  set_has_vehicletype();
  vehicletype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:atd.taskmanager.fusion.RouteInfo.vehicleType)
}
#endif
inline void RouteInfo::set_vehicletype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vehicletype();
  vehicletype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atd.taskmanager.fusion.RouteInfo.vehicleType)
}
inline void RouteInfo::set_vehicletype(const char* value, size_t size) {
  set_has_vehicletype();
  vehicletype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atd.taskmanager.fusion.RouteInfo.vehicleType)
}
inline ::std::string* RouteInfo::mutable_vehicletype() {
  set_has_vehicletype();
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.RouteInfo.vehicleType)
  return vehicletype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteInfo::release_vehicletype() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.RouteInfo.vehicleType)
  if (!has_vehicletype()) {
    return NULL;
  }
  clear_has_vehicletype();
  return vehicletype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteInfo::set_allocated_vehicletype(::std::string* vehicletype) {
  if (vehicletype != NULL) {
    set_has_vehicletype();
  } else {
    clear_has_vehicletype();
  }
  vehicletype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicletype);
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.RouteInfo.vehicleType)
}

// optional .atd.taskmanager.fusion.Point centerCoordinate = 3;
inline bool RouteInfo::has_centercoordinate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteInfo::set_has_centercoordinate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteInfo::clear_has_centercoordinate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteInfo::clear_centercoordinate() {
  if (centercoordinate_ != NULL) centercoordinate_->Clear();
  clear_has_centercoordinate();
}
inline const ::atd::taskmanager::fusion::Point& RouteInfo::_internal_centercoordinate() const {
  return *centercoordinate_;
}
inline const ::atd::taskmanager::fusion::Point& RouteInfo::centercoordinate() const {
  const ::atd::taskmanager::fusion::Point* p = centercoordinate_;
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.centerCoordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::atd::taskmanager::fusion::Point*>(
      &::atd::taskmanager::fusion::_Point_default_instance_);
}
inline ::atd::taskmanager::fusion::Point* RouteInfo::release_centercoordinate() {
  // @@protoc_insertion_point(field_release:atd.taskmanager.fusion.RouteInfo.centerCoordinate)
  clear_has_centercoordinate();
  ::atd::taskmanager::fusion::Point* temp = centercoordinate_;
  centercoordinate_ = NULL;
  return temp;
}
inline ::atd::taskmanager::fusion::Point* RouteInfo::mutable_centercoordinate() {
  set_has_centercoordinate();
  if (centercoordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::atd::taskmanager::fusion::Point>(GetArenaNoVirtual());
    centercoordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.RouteInfo.centerCoordinate)
  return centercoordinate_;
}
inline void RouteInfo::set_allocated_centercoordinate(::atd::taskmanager::fusion::Point* centercoordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete centercoordinate_;
  }
  if (centercoordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      centercoordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, centercoordinate, submessage_arena);
    }
    set_has_centercoordinate();
  } else {
    clear_has_centercoordinate();
  }
  centercoordinate_ = centercoordinate;
  // @@protoc_insertion_point(field_set_allocated:atd.taskmanager.fusion.RouteInfo.centerCoordinate)
}

// optional int64 coordinateTime = 4;
inline bool RouteInfo::has_coordinatetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteInfo::set_has_coordinatetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteInfo::clear_has_coordinatetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteInfo::clear_coordinatetime() {
  coordinatetime_ = GOOGLE_LONGLONG(0);
  clear_has_coordinatetime();
}
inline ::google::protobuf::int64 RouteInfo::coordinatetime() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.coordinateTime)
  return coordinatetime_;
}
inline void RouteInfo::set_coordinatetime(::google::protobuf::int64 value) {
  set_has_coordinatetime();
  coordinatetime_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.coordinateTime)
}

// repeated .atd.taskmanager.fusion.Point route = 5;
inline int RouteInfo::route_size() const {
  return route_.size();
}
inline void RouteInfo::clear_route() {
  route_.Clear();
}
inline ::atd::taskmanager::fusion::Point* RouteInfo::mutable_route(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.RouteInfo.route)
  return route_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >*
RouteInfo::mutable_route() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.RouteInfo.route)
  return &route_;
}
inline const ::atd::taskmanager::fusion::Point& RouteInfo::route(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.route)
  return route_.Get(index);
}
inline ::atd::taskmanager::fusion::Point* RouteInfo::add_route() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.RouteInfo.route)
  return route_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::Point >&
RouteInfo::route() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.RouteInfo.route)
  return route_;
}

// optional int64 routeTime = 6;
inline bool RouteInfo::has_routetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteInfo::set_has_routetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteInfo::clear_has_routetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteInfo::clear_routetime() {
  routetime_ = GOOGLE_LONGLONG(0);
  clear_has_routetime();
}
inline ::google::protobuf::int64 RouteInfo::routetime() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.routeTime)
  return routetime_;
}
inline void RouteInfo::set_routetime(::google::protobuf::int64 value) {
  set_has_routetime();
  routetime_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.routeTime)
}

// optional float speed = 7;
inline bool RouteInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float RouteInfo::speed() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.speed)
  return speed_;
}
inline void RouteInfo::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.speed)
}

// optional float heading = 8;
inline bool RouteInfo::has_heading() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RouteInfo::set_has_heading() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RouteInfo::clear_has_heading() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RouteInfo::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float RouteInfo::heading() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.heading)
  return heading_;
}
inline void RouteInfo::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.heading)
}

// optional int32 workingMode = 9;
inline bool RouteInfo::has_workingmode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RouteInfo::set_has_workingmode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RouteInfo::clear_has_workingmode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RouteInfo::clear_workingmode() {
  workingmode_ = 0;
  clear_has_workingmode();
}
inline ::google::protobuf::int32 RouteInfo::workingmode() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.workingMode)
  return workingmode_;
}
inline void RouteInfo::set_workingmode(::google::protobuf::int32 value) {
  set_has_workingmode();
  workingmode_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.workingMode)
}

// optional int32 taskType = 10;
inline bool RouteInfo::has_tasktype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RouteInfo::set_has_tasktype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RouteInfo::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RouteInfo::clear_tasktype() {
  tasktype_ = 0;
  clear_has_tasktype();
}
inline ::google::protobuf::int32 RouteInfo::tasktype() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.taskType)
  return tasktype_;
}
inline void RouteInfo::set_tasktype(::google::protobuf::int32 value) {
  set_has_tasktype();
  tasktype_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.taskType)
}

// repeated double axisAngle = 11;
inline int RouteInfo::axisangle_size() const {
  return axisangle_.size();
}
inline void RouteInfo::clear_axisangle() {
  axisangle_.Clear();
}
inline double RouteInfo::axisangle(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.RouteInfo.axisAngle)
  return axisangle_.Get(index);
}
inline void RouteInfo::set_axisangle(int index, double value) {
  axisangle_.Set(index, value);
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.RouteInfo.axisAngle)
}
inline void RouteInfo::add_axisangle(double value) {
  axisangle_.Add(value);
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.RouteInfo.axisAngle)
}
inline const ::google::protobuf::RepeatedField< double >&
RouteInfo::axisangle() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.RouteInfo.axisAngle)
  return axisangle_;
}
inline ::google::protobuf::RepeatedField< double >*
RouteInfo::mutable_axisangle() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.RouteInfo.axisAngle)
  return &axisangle_;
}

// -------------------------------------------------------------------

// MultipleVehiclesRoutes

// optional int64 timestamp = 1;
inline bool MultipleVehiclesRoutes::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultipleVehiclesRoutes::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultipleVehiclesRoutes::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultipleVehiclesRoutes::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MultipleVehiclesRoutes::timestamp() const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.MultipleVehiclesRoutes.timestamp)
  return timestamp_;
}
inline void MultipleVehiclesRoutes::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:atd.taskmanager.fusion.MultipleVehiclesRoutes.timestamp)
}

// repeated .atd.taskmanager.fusion.RouteInfo MultipleVehiclesRoutes = 2;
inline int MultipleVehiclesRoutes::multiplevehiclesroutes_size() const {
  return multiplevehiclesroutes_.size();
}
inline void MultipleVehiclesRoutes::clear_multiplevehiclesroutes() {
  multiplevehiclesroutes_.Clear();
}
inline ::atd::taskmanager::fusion::RouteInfo* MultipleVehiclesRoutes::mutable_multiplevehiclesroutes(int index) {
  // @@protoc_insertion_point(field_mutable:atd.taskmanager.fusion.MultipleVehiclesRoutes.MultipleVehiclesRoutes)
  return multiplevehiclesroutes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::RouteInfo >*
MultipleVehiclesRoutes::mutable_multiplevehiclesroutes() {
  // @@protoc_insertion_point(field_mutable_list:atd.taskmanager.fusion.MultipleVehiclesRoutes.MultipleVehiclesRoutes)
  return &multiplevehiclesroutes_;
}
inline const ::atd::taskmanager::fusion::RouteInfo& MultipleVehiclesRoutes::multiplevehiclesroutes(int index) const {
  // @@protoc_insertion_point(field_get:atd.taskmanager.fusion.MultipleVehiclesRoutes.MultipleVehiclesRoutes)
  return multiplevehiclesroutes_.Get(index);
}
inline ::atd::taskmanager::fusion::RouteInfo* MultipleVehiclesRoutes::add_multiplevehiclesroutes() {
  // @@protoc_insertion_point(field_add:atd.taskmanager.fusion.MultipleVehiclesRoutes.MultipleVehiclesRoutes)
  return multiplevehiclesroutes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::atd::taskmanager::fusion::RouteInfo >&
MultipleVehiclesRoutes::multiplevehiclesroutes() const {
  // @@protoc_insertion_point(field_list:atd.taskmanager.fusion.MultipleVehiclesRoutes.MultipleVehiclesRoutes)
  return multiplevehiclesroutes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fusion
}  // namespace taskmanager
}  // namespace atd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_taskmanager_5ffusion_2eproto
